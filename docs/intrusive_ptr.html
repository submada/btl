
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>btl.autoptr.intrusive_ptr</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">btl.autoptr.intrusive_ptr</h1>
        <section id="module_content"><section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Implementation of intrusive reference counted pointer <code class="code">IntrusivePtr</code> (similar to c++ <code class="code">std::enable_shared_from_this</code>).

  </p>
</div>
<div class="ddoc_license">
  <h4>License</h4>
  <p class="para">
    .

  </p>
</div>
<div class="ddoc_authors">
  <h4>Authors</h4>
  <p class="para">
    
  </p>
</div>

</section>
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#isIntrusivePtr" id="isIntrusivePtr"><code class="code">isIntrusivePtr</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="isIntrusivePtr"></span>enum bool <code class="code">isIntrusivePtr</code>(T);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Check if type <code class="code">T</code> is <code class="code">IntrusivePtr</code>.
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">assert</span>(!<span class="psymbol">isIntrusivePtr</span>!<span class="keyword">long</span>);
<span class="keyword">static</span> <span class="keyword">assert</span>(!<span class="psymbol">isIntrusivePtr</span>!(<span class="keyword">void</span>*));

<span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) control;
}
<span class="keyword">static</span> <span class="keyword">assert</span>(<span class="psymbol">isIntrusivePtr</span>!(IntrusivePtr!Foo));
<span class="keyword">static</span> <span class="keyword">assert</span>(<span class="psymbol">isIntrusivePtr</span>!(IntrusivePtr!Foo.WeakType));
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr" id="IntrusivePtr"><code class="code">IntrusivePtr</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr"></span>struct <code class="code">IntrusivePtr</code>(_Type, bool _weakPtr = false);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Implementation of a ref counted pointer that points to an object with an embedded reference counter <code class="code">btl.autoptr.common.ControlBlock</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    <code class="code"><code class="code">IntrusivePtr</code></code> retains shared ownership of an object through a pointer.
<br><br>
    Several ref counted pointer objects may own the same object.
<br><br>
    The object is destroyed and its memory deallocated when either of the following happens:

<ol><li>the last remaining ref counted pointer owning the object is destroyed.
</li>
<li>the last remaining ref counted pointer owning the object is assigned another pointer via various methods like <code class="code">opAssign</code> and <code class="code">store</code>.
</li>
</ol>
    The object is destroyed using destructor of type <code class="code">_Type</code>.
<br><br>
    A <code class="code"><code class="code">IntrusivePtr</code></code> can not share ownership of an object while storing a pointer to another object (use <code class="code">SharedPtr</code> for that).
<br><br>
    A <code class="code"><code class="code">IntrusivePtr</code></code> may also own no objects, in which case it is called empty.
<br><br>
    <code class="code">_Type</code> must contain one property of type <code class="code">ControlBlock</code> (this property contains ref counting). If this property is <code class="code">shared</code> then ref counting is atomic.
<br><br>
    If <code class="code">_Type</code> is const/immutable then ControlBlock cannot be modified =&gt; ref counting doesn't work and <code class="code"><code class="code">IntrusivePtr</code></code> can be only moved.
<br><br>
    If multiple threads of execution access the same <code class="code"><code class="code">IntrusivePtr</code></code> (<code class="code">shared <code class="code">IntrusivePtr</code></code>) then only some methods can be called (<code class="code">load</code>, <code class="code">store</code>, <code class="code">exchange</code>, <code class="code">compareExchange</code>, <code class="code">useCount</code>).
<br><br>
    Template parameters:
<br><br>
        <code class="code">_Type</code> type of managed object
<br><br>
        <code class="code">_weakPtr</code> if <code class="code">true</code> then <code class="code"><code class="code">IntrusivePtr</code></code> represent weak ptr
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Struct{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) control;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

<span class="keyword">static</span> <span class="keyword">class</span> Base{
    <span class="keyword">int</span> i;
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) control;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}
<span class="keyword">static</span> <span class="keyword">class</span> Derived : Base{
    <span class="keyword">double</span> d;

    <span class="keyword">this</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> d)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">super</span>(i);
        <span class="keyword">this</span>.d = d;
    }
}
<span class="keyword">static</span> <span class="keyword">class</span> Class : Derived{
    <span class="keyword">bool</span> b;
    <span class="keyword">this</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> d, <span class="keyword">bool</span> b)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">super</span>(i, d);
        <span class="keyword">this</span>.b = b;
    }
}

<span class="comment">///simple:
</span>{
    <span class="psymbol">IntrusivePtr</span>!Struct a = <span class="psymbol">IntrusivePtr</span>!Struct.make(42);
    <span class="keyword">assert</span>(a.useCount == 1);

    <span class="psymbol">IntrusivePtr</span>!(<span class="keyword">const</span> Struct) b = a;
    <span class="keyword">assert</span>(a.useCount == 2);

    <span class="psymbol">IntrusivePtr</span>!Struct.WeakType w = a.weak;
    <span class="keyword">assert</span>(a.useCount == 2);
    <span class="keyword">assert</span>(a.weakCount == 1);

    <span class="psymbol">IntrusivePtr</span>!Struct c = w.lock;
    <span class="keyword">assert</span>(a.useCount == 3);
    <span class="keyword">assert</span>(a.weakCount == 1);

    <span class="keyword">assert</span>(c.get.i == 42);
}

<span class="comment">///polymorphism and aliasing:
</span>{
    <span class="comment">///create IntrusivePtr
</span>    <span class="psymbol">IntrusivePtr</span>!Base foo = <span class="psymbol">IntrusivePtr</span>!Derived.make(42, 3.14);
    <span class="psymbol">IntrusivePtr</span>!Class zee = <span class="psymbol">IntrusivePtr</span>!Class.make(42, 3.14, <span class="keyword">false</span>);

    <span class="comment">///dynamic cast:
</span>    <span class="psymbol">IntrusivePtr</span>!Derived bar = dynCast!Derived(foo);
    <span class="keyword">assert</span>(bar != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(foo.useCount == 2);

    <span class="comment">///this doesnt work because Foo destructor attributes are more restrictive then Class's:
</span>    <span class="comment">//IntrusivePtr!Class x = zee;
</span>
    <span class="comment">///this does work:
</span>    <span class="psymbol">IntrusivePtr</span>!Base x = zee;
    <span class="keyword">assert</span>(zee.useCount == 2);
}


<span class="comment">///multi threading:
</span>{
    <span class="comment">///create IntrusivePtr with atomic ref counting
</span>    <span class="psymbol">IntrusivePtr</span>!(<span class="keyword">shared</span> Base) foo = <span class="psymbol">IntrusivePtr</span>!(<span class="keyword">shared</span> Derived).make(42, 3.14);

    <span class="comment">///this doesnt work:
</span>    <span class="comment">//foo.get.i += 1;
</span>
    <span class="keyword">import</span> core.atomic : atomicFetchAdd;
    atomicFetchAdd(foo.get.i, 1);
    <span class="keyword">assert</span>(foo.get.i == 43);


    <span class="comment">///creating `shared(IntrusivePtr)`:
</span>    <span class="keyword">shared</span> <span class="psymbol">IntrusivePtr</span>!(<span class="keyword">shared</span> Derived) bar = share(dynCast!Derived(foo));

    <span class="comment">///`shared(IntrusivePtr)` is lock free (except `load` and `useCount`/`weakCount`).
</span>    <span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">typeof</span>(bar).isLockFree == <span class="keyword">true</span>);

    <span class="comment">///multi thread operations (`load`, `store`, `exchange` and `compareExchange`):
</span>    <span class="psymbol">IntrusivePtr</span>!(<span class="keyword">shared</span> Derived) bar2 = bar.load();
    <span class="keyword">assert</span>(bar2 != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(bar2.useCount == 3);

    <span class="psymbol">IntrusivePtr</span>!(<span class="keyword">shared</span> Derived) bar3 = bar.exchange(<span class="keyword">null</span>);
    <span class="keyword">assert</span>(bar3 != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(bar3.useCount == 3);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">//make IntrusivePtr object
</span><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    <span class="keyword">auto</span> foo = <span class="psymbol">IntrusivePtr</span>!Foo.make(42);
    <span class="keyword">auto</span> foo2 = <span class="psymbol">IntrusivePtr</span>!Foo.make!Mallocator(42);  <span class="comment">//explicit stateless allocator
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.experimental.allocator : make, dispose, allocatorObject;

<span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }

    ~<span class="keyword">this</span>(){
        <span class="keyword">if</span>(<span class="keyword">false</span>)
            <span class="keyword">auto</span> allocator = allocatorObject(Mallocator.instance);
    }
}

<span class="comment">//alloc IntrusivePtr object
</span>
<span class="keyword">auto</span> allocator = allocatorObject(Mallocator.instance);

{
    <span class="keyword">auto</span> x = <span class="psymbol">IntrusivePtr</span>!Foo.alloc(allocator, 42);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.ElementType" id="IntrusivePtr.ElementType"><code class="code">ElementType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.ElementType"></span>alias <code class="code">ElementType</code> = _Type;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Type of element managed by <code class="code">IntrusivePtr</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.DestructorType" id="IntrusivePtr.DestructorType"><code class="code">DestructorType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.DestructorType"></span>alias <code class="code">DestructorType</code> = .<code class="code">DestructorType</code>!ElementType;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Type of destructor (<code class="code">void function(void*)@attributes</code>).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.ControlType" id="IntrusivePtr.ControlType"><code class="code">ControlType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.ControlType"></span>alias <code class="code">ControlType</code> = _ControlType;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Type of control block.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.sharedControl" id="IntrusivePtr.sharedControl"><code class="code">sharedControl</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.sharedControl"></span>enum bool <code class="code">sharedControl</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <code class="code">true</code> if <code class="code">ControlBlock</code> is shared
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.isWeak" id="IntrusivePtr.isWeak"><code class="code">isWeak</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.isWeak"></span>alias <code class="code">isWeak</code> = _weakPtr;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <code class="code">true</code> if <code class="code">IntrusivePtr</code> is weak ptr.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.ElementReferenceType" id="IntrusivePtr.ElementReferenceType"><code class="code">ElementReferenceType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.ElementReferenceType"></span>alias <code class="code">ElementReferenceType</code> = ElementReferenceTypeImpl!ElementType;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Same as <code class="code">ElementType*</code> or <code class="code">ElementType</code> if is class/interface/slice.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.WeakType" id="IntrusivePtr.WeakType"><code class="code">WeakType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.WeakType"></span>alias <code class="code">WeakType</code> = IntrusivePtr!(_Type, true);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Weak pointer

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    <code class="code">IntrusivePtr.<code class="code">WeakType</code></code> is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by <code class="code">IntrusivePtr</code>.
            It must be converted to <code class="code">IntrusivePtr</code> in order to access the referenced object.
<br><br>
            <code class="code">IntrusivePtr.<code class="code">WeakType</code></code> models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else,
            <code class="code">IntrusivePtr.<code class="code">WeakType</code></code> is used to track the object, and it is converted to <code class="code">IntrusivePtr</code> to assume temporary ownership.
            If the original <code class="code">IntrusivePtr</code> is destroyed at this time, the object's lifetime is extended until the temporary <code class="code">IntrusivePtr</code> is destroyed as well.
<br><br>
            Another use for <code class="code">IntrusivePtr.<code class="code">WeakType</code></code> is to break reference cycles formed by objects managed by <code class="code">IntrusivePtr</code>.
            If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the <code class="code">IntrusivePtr</code> reference counts cannot reach zero and the memory is leaked.
            To prevent this, one of the pointers in the cycle can be made weak.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.SharedType" id="IntrusivePtr.SharedType"><code class="code">SharedType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.SharedType"></span>alias <code class="code">SharedType</code> = IntrusivePtr!(_Type, false);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Type of non weak ptr.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.isLockFree" id="IntrusivePtr.isLockFree"><code class="code">isLockFree</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.isLockFree"></span>alias <code class="code">isLockFree</code> = _isLockFree;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <code class="code">true</code> if shared <code class="code">IntrusivePtr</code> has lock free operations <code class="code">store</code>, <code class="code">load</code>, <code class="code">exchange</code>, <code class="code">compareExchange</code>, otherwise '<code class="code">false</code>'
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.this" id="IntrusivePtr.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.this"></span>pure nothrow @nogc @safe this(this This)(typeof(null) <code class="code">nil</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Constructs a <code class="code">IntrusivePtr</code> without managed object. Same as <code class="code">IntrusivePtr.init</code>

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
}

{
    IntrusivePtr!Foo x = <span class="keyword">null</span>;

    <span class="keyword">assert</span>(x == <span class="keyword">null</span>);
    <span class="keyword">assert</span>(x == IntrusivePtr!Foo.init);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.this" id="IntrusivePtr.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.this.2"></span>@trusted this(Rhs, this This)(auto ref scope Rhs <code class="code">rhs</code>) if (isIntrusivePtr!Rhs &amp;&amp; isConstructable!(<code class="code">rhs</code>, This) &amp;&amp; !is(Rhs == shared) &amp;&amp; !isMoveCtor!(This, <code class="code">rhs</code>));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Constructs a <code class="code">IntrusivePtr</code> which shares ownership of the object managed by <code class="code"><code class="code">rhs</code></code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If <code class="code">rhs</code> manages no object, this manages no object too.
            If <code class="code">rhs</code> if rvalue then ownership is moved.
            The template overload doesn't participate in overload resolution if ElementType of <code class="code">typeof(<code class="code">rhs</code>)</code> is not implicitly convertible to <code class="code">ElementType</code>.
            If <code class="code">rhs</code> if <code class="code">WeakType</code> then this ctor is equivalent to <code class="code">this(<code class="code">rhs</code>.lock())</code>.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    MutableControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
    <span class="keyword">assert</span>(x.useCount == 1);

    IntrusivePtr!Foo a = x;         <span class="comment">//lvalue copy ctor
</span>    <span class="keyword">assert</span>(a == x);

    <span class="keyword">const</span> IntrusivePtr!Foo b = x;   <span class="comment">//lvalue copy ctor
</span>    <span class="keyword">assert</span>(b == x);

    IntrusivePtr!Foo c = x; <span class="comment">//lvalue ctor
</span>    <span class="keyword">assert</span>(c == x);

    <span class="keyword">const</span> IntrusivePtr!Foo d = b;   <span class="comment">//lvalue ctor
</span>    <span class="keyword">assert</span>(d == x);

    <span class="keyword">assert</span>(x.useCount == 5);
}

{
    <span class="keyword">import</span> core.lifetime : move;
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
    <span class="keyword">assert</span>(x.useCount == 1);

    IntrusivePtr!Foo a = move(x);        <span class="comment">//rvalue copy ctor
</span>    <span class="keyword">assert</span>(a.useCount == 1);

    <span class="keyword">const</span> IntrusivePtr!Foo b = move(a);  <span class="comment">//rvalue copy ctor
</span>    <span class="keyword">assert</span>(b.useCount == 1);

    IntrusivePtr!(<span class="keyword">const</span> Foo) c = b.load;  <span class="comment">//rvalue ctor
</span>    <span class="keyword">assert</span>(c.useCount == 2);

    <span class="keyword">const</span> IntrusivePtr!Foo d = move(c);  <span class="comment">//rvalue ctor
</span>    <span class="keyword">assert</span>(d.useCount == 2);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opAssign" id="IntrusivePtr.opAssign"><code class="code">opAssign</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opAssign"></span>scope void <code class="code">opAssign</code>(MemoryOrder order = MemoryOrder.seq, this This)(typeof(null) <code class="code">nil</code>) if (isMutable!This);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Releases the ownership of the managed object, if any.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    After the call, this manages no object.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(1);

    <span class="keyword">assert</span>(x.useCount == 1);
    x = <span class="keyword">null</span>;
    <span class="keyword">assert</span>(x.useCount == 0);
    <span class="keyword">assert</span>(x == <span class="keyword">null</span>);
}

{
    IntrusivePtr!(<span class="keyword">shared</span> Foo) x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(1);

    <span class="keyword">assert</span>(x.useCount == 1);
    x = <span class="keyword">null</span>;
    <span class="keyword">assert</span>(x.useCount == 0);
    <span class="keyword">assert</span>(x == <span class="keyword">null</span>);
}

{
    <span class="keyword">shared</span> IntrusivePtr!(<span class="keyword">shared</span> Foo) x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(1);

    <span class="keyword">assert</span>(x.useCount == 1);
    x = <span class="keyword">null</span>;
    <span class="keyword">assert</span>(x.useCount == 0);
    <span class="keyword">assert</span>(x.load == <span class="keyword">null</span>);

}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opAssign" id="IntrusivePtr.opAssign"><code class="code">opAssign</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opAssign.2"></span>scope void <code class="code">opAssign</code>(MemoryOrder order = MemoryOrder.seq, Rhs, this This)(auto ref scope Rhs <code class="code">desired</code>) if (isIntrusivePtr!Rhs &amp;&amp; isAssignable!(<code class="code">desired</code>, This) &amp;&amp; !is(Rhs == shared));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Shares ownership of the object managed by <code class="code">rhs</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If <code class="code">rhs</code> manages no object, <code class="code">this</code> manages no object too.
            If <code class="code">rhs</code> is rvalue then move-assigns a <code class="code">IntrusivePtr</code> from <code class="code">rhs</code>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    MutableControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo px1 = IntrusivePtr!Foo.make(1);
    IntrusivePtr!Foo px2 = IntrusivePtr!Foo.make(2);

    <span class="keyword">assert</span>(px2.useCount == 1);
    px1 = px2;
    <span class="keyword">assert</span>(px1.get.i == 2);
    <span class="keyword">assert</span>(px2.useCount == 2);
}


{
    IntrusivePtr!(Foo) px = IntrusivePtr!(Foo).make(1);
    IntrusivePtr!(<span class="keyword">const</span> Foo) pcx = IntrusivePtr!(Foo).make(2);

    <span class="keyword">assert</span>(px.useCount == 1);
    pcx = px;
    <span class="keyword">assert</span>(pcx.get.i == 1);
    <span class="keyword">assert</span>(pcx.useCount == 2);
}


{
    <span class="keyword">const</span> IntrusivePtr!(Foo) cpx = IntrusivePtr!(Foo).make(1);
    IntrusivePtr!(<span class="keyword">const</span> Foo) pcx = IntrusivePtr!(Foo).make(2);

    <span class="keyword">assert</span>(pcx.useCount == 1);
    pcx = cpx;
    <span class="keyword">assert</span>(pcx.get.i == 1);
    <span class="keyword">assert</span>(pcx.useCount == 2);
}

{
    IntrusivePtr!(<span class="keyword">immutable</span> Foo) pix = IntrusivePtr!(<span class="keyword">immutable</span> Foo).make(123);
    IntrusivePtr!(<span class="keyword">const</span> Foo) pcx = IntrusivePtr!(Foo).make(2);

    <span class="keyword">assert</span>(pix.useCount == 1);
    pcx = pix;
    <span class="keyword">assert</span>(pcx.get.i == 123);
    <span class="keyword">assert</span>(pcx.useCount == 2);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.make" id="IntrusivePtr.make"><code class="code">make</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.make"></span>IntrusivePtr!ElementType <code class="code">make</code>(AllocatorType = DefaultAllocator, bool supportGC = platformSupportGC, Args...)(auto ref Args <code class="code">args</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Constructs an object of type <code class="code">ElementType</code> and wraps it in a <code class="code">IntrusivePtr</code> using <code class="code">args</code> as the parameter list for the constructor of <code class="code">ElementType</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The object is constructed as if by the expression <code class="code">emplace!ElementType(_payload, forward!<code class="code">args</code>)</code>, where payload is an internal pointer to storage suitable to hold an object of type <code class="code">ElementType</code>.
            The storage is typically larger than <code class="code">ElementType.sizeof</code> in order to use one allocation for both the control block and the <code class="code">ElementType</code> object.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo a = IntrusivePtr!Foo.<span class="psymbol">make</span>();
    <span class="keyword">assert</span>(a.get.i == 0);

    IntrusivePtr!(<span class="keyword">const</span> Foo) b = IntrusivePtr!Foo.<span class="psymbol">make</span>(2);
    <span class="keyword">assert</span>(b.get.i == 2);
}

{
    <span class="keyword">static</span> <span class="keyword">struct</span> Struct{
        ControlBlock!<span class="keyword">int</span> c;
        <span class="keyword">int</span> i = 7;

        <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
            <span class="keyword">this</span>.i = i;
        }
    }

    IntrusivePtr!Struct s1 = IntrusivePtr!Struct.<span class="psymbol">make</span>();
    <span class="keyword">assert</span>(s1.get.i == 7);

    IntrusivePtr!Struct s2 = IntrusivePtr!Struct.<span class="psymbol">make</span>(123);
    <span class="keyword">assert</span>(s2.get.i == 123);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.alloc" id="IntrusivePtr.alloc"><code class="code">alloc</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.alloc"></span>IntrusivePtr!ElementType <code class="code">alloc</code>(bool supportGC = platformSupportGC, AllocatorType, Args...)(AllocatorType <code class="code">a</code>, auto ref Args <code class="code">args</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Constructs an object of type <code class="code">ElementType</code> and wraps it in <code class="code">a</code> <code class="code">IntrusivePtr</code> using <code class="code">args</code> as the parameter list for the constructor of <code class="code">ElementType</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The object is constructed as if by the expression <code class="code">emplace!ElementType(_payload, forward!<code class="code">args</code>)</code>, where payload is an internal pointer to storage suitable to hold an object of type <code class="code">ElementType</code>.
            The storage is typically larger than <code class="code">ElementType.sizeof</code> in order to use one allocation for both the control block and the <code class="code">ElementType</code> object.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    <span class="keyword">import</span> std.experimental.allocator : allocatorObject;

    <span class="keyword">auto</span> <span class="param">a</span> = allocatorObject(Mallocator.instance);
    {
        <span class="keyword">auto</span> x = IntrusivePtr!Foo.<span class="psymbol">alloc</span>(<span class="param">a</span>);
        <span class="keyword">assert</span>(x.get.i == 0);

        <span class="keyword">auto</span> y = IntrusivePtr!(<span class="keyword">const</span> Foo).<span class="psymbol">alloc</span>(<span class="param">a</span>, 2);
        <span class="keyword">assert</span>(y.get.i == 2);
    }

    {
        <span class="keyword">static</span> <span class="keyword">struct</span> Struct{
            ControlBlock!(<span class="keyword">int</span>) c;
            <span class="keyword">int</span> i = 7;

            <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
                <span class="keyword">this</span>.i = i;
            }
        }

        <span class="keyword">auto</span> s1 = IntrusivePtr!Struct.<span class="psymbol">alloc</span>(<span class="param">a</span>);
        <span class="keyword">assert</span>(s1.get.i == 7);

        <span class="keyword">auto</span> s2 = IntrusivePtr!Struct.<span class="psymbol">alloc</span>(<span class="param">a</span>, 123);
        <span class="keyword">assert</span>(s2.get.i == 123);
    }

}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.useCount" id="IntrusivePtr.useCount"><code class="code">useCount</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.useCount"></span>const nothrow @nogc @property scope @safe ControlType.Shared <code class="code">useCount</code>(this This)();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the number of different <code class="code">IntrusivePtr</code> instances

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Returns the number of different <code class="code">IntrusivePtr</code> instances (<code class="code">this</code> included) managing the current object or <code class="code">0</code> if there is no managed object.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}


IntrusivePtr!Foo x = <span class="keyword">null</span>;

<span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 0);

x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 1);

<span class="keyword">auto</span> y = x;
<span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 2);

<span class="keyword">auto</span> w1 = x.weak;    <span class="comment">//weak ptr
</span><span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 2);

IntrusivePtr!Foo.WeakType w2 = x;   <span class="comment">//weak ptr
</span><span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 2);

y = <span class="keyword">null</span>;
<span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 1);

x = <span class="keyword">null</span>;
<span class="keyword">assert</span>(x.<span class="psymbol">useCount</span> == 0);
<span class="keyword">assert</span>(w1.<span class="psymbol">useCount</span> == 0);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.weakCount" id="IntrusivePtr.weakCount"><code class="code">weakCount</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.weakCount"></span>const nothrow @nogc @property scope @safe ControlType.Weak <code class="code">weakCount</code>(this This)();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the number of different <code class="code">IntrusivePtr.WeakType</code> instances

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Returns the number of different <code class="code">IntrusivePtr.WeakType</code> instances (<code class="code">this</code> included) managing the current object or <code class="code">0</code> if there is no managed object.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

IntrusivePtr!Foo x = <span class="keyword">null</span>;
<span class="keyword">assert</span>(x.useCount == 0);
<span class="keyword">assert</span>(x.<span class="psymbol">weakCount</span> == 0);

x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(x.useCount == 1);
<span class="keyword">assert</span>(x.<span class="psymbol">weakCount</span> == 0);

<span class="keyword">auto</span> w = x.weak();
<span class="keyword">assert</span>(x.useCount == 1);
<span class="keyword">assert</span>(x.<span class="psymbol">weakCount</span> == 1);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.proxySwap" id="IntrusivePtr.proxySwap"><code class="code">proxySwap</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.proxySwap"></span>pure nothrow @nogc scope @trusted void <code class="code">proxySwap</code>(ref scope typeof(this) <code class="code">rhs</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Swap <code class="code">this</code> with <code class="code"><code class="code">rhs</code></code>

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo a = IntrusivePtr!Foo.make(1);
    IntrusivePtr!Foo b = IntrusivePtr!Foo.make(2);
    a.<span class="psymbol">proxySwap</span>(b);
    <span class="keyword">assert</span>(a != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(b != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(a.get.i == 2);
    <span class="keyword">assert</span>(b.get.i == 1);
    <span class="keyword">import</span> std.algorithm : swap;
    swap(a, b);
    <span class="keyword">assert</span>(a.get.i == 1);
    <span class="keyword">assert</span>(b.get.i == 2);
    <span class="keyword">assert</span>(a.useCount == 1);
    <span class="keyword">assert</span>(b.useCount == 1);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.load" id="IntrusivePtr.load"><code class="code">load</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.load"></span>scope UnqualSmartPtr!This <code class="code">load</code>(MemoryOrder order = MemoryOrder.seq, this This)();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the non <code class="code">shared</code> <code class="code">IntrusivePtr</code> pointer pointed-to by <code class="code">shared</code> <code class="code">this</code>.

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

<span class="keyword">shared</span> IntrusivePtr!(<span class="keyword">shared</span> Foo) x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);

{
    IntrusivePtr!(<span class="keyword">shared</span> Foo) y = x.<span class="psymbol">load</span>();
    <span class="keyword">assert</span>(y.useCount == 2);

    <span class="keyword">assert</span>(y.get.i == 123);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.store" id="IntrusivePtr.store"><code class="code">store</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.store"></span>alias <code class="code">store</code> = opAssign;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Stores the non <code class="code">shared</code> <code class="code">IntrusivePtr</code> parameter <code class="code">ptr</code> to <code class="code">this</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If <code class="code">this</code> is shared then operation is atomic or guarded by mutex.
<br><br>
            Template parameter <code class="code">order</code> has type <code class="code">core.atomic.MemoryOrder</code>.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

<span class="comment">//null store:
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">assert</span>(x.load.get.i == 123);

    x.<span class="psymbol">store</span>(<span class="keyword">null</span>);
    <span class="keyword">assert</span>(x.useCount == 0);
    <span class="keyword">assert</span>(x.load == <span class="keyword">null</span>);
}

<span class="comment">//rvalue store:
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">assert</span>(x.load.get.i == 123);

    x.<span class="psymbol">store</span>(IntrusivePtr!(<span class="keyword">shared</span> Foo).make(42));
    <span class="keyword">assert</span>(x.load.get.i == 42);
}

<span class="comment">//lvalue store:
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">auto</span> y = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(42);

    <span class="keyword">assert</span>(x.load.get.i == 123);
    <span class="keyword">assert</span>(y.load.get.i == 42);

    x.<span class="psymbol">store</span>(y);
    <span class="keyword">assert</span>(x.load.get.i == 42);
    <span class="keyword">assert</span>(x.useCount == 2);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.exchange" id="IntrusivePtr.exchange"><code class="code">exchange</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.exchange"></span>scope IntrusivePtr <code class="code">exchange</code>(MemoryOrder order = MemoryOrder.seq, this This)(typeof(null)) if (isMutable!This);
<br>
scope IntrusivePtr <code class="code">exchange</code>(MemoryOrder order = MemoryOrder.seq, Rhs, this This)(scope Rhs <code class="code">ptr</code>) if (isIntrusivePtr!Rhs &amp;&amp; !is(Rhs == shared) &amp;&amp; isMoveConstructable!(Rhs, This) &amp;&amp; isMutable!This);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Stores the non <code class="code">shared</code> <code class="code">IntrusivePtr</code> pointer <code class="code">ptr</code> in the <code class="code">shared(IntrusivePtr)</code> pointed to by <code class="code">this</code> and returns the value formerly pointed-to by this, atomically or with mutex.

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

<span class="comment">//lvalue exchange
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">auto</span> y = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(42);

    <span class="keyword">auto</span> z = x.<span class="psymbol">exchange</span>(y);

    <span class="keyword">assert</span>(x.load.get.i == 42);
    <span class="keyword">assert</span>(y.get.i == 42);
    <span class="keyword">assert</span>(z.get.i == 123);
}

<span class="comment">//rvalue exchange
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">auto</span> y = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(42);

    <span class="keyword">import</span> core.lifetime : move;
    <span class="keyword">auto</span> z = x.<span class="psymbol">exchange</span>(move(y));

    <span class="keyword">assert</span>(x.load.get.i == 42);
    <span class="keyword">assert</span>(y == <span class="keyword">null</span>);
    <span class="keyword">assert</span>(z.get.i == 123);
}

<span class="comment">//null exchange (same as move)
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);

    <span class="keyword">auto</span> z = x.<span class="psymbol">exchange</span>(<span class="keyword">null</span>);

    <span class="keyword">assert</span>(x.load == <span class="keyword">null</span>);
    <span class="keyword">assert</span>(z.get.i == 123);
}

<span class="comment">//swap:
</span>{
    <span class="keyword">shared</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">auto</span> y = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(42);

    <span class="comment">//opAssign is same as store
</span>    <span class="keyword">import</span> core.lifetime : move;
    y = x.<span class="psymbol">exchange</span>(move(y));

    <span class="keyword">assert</span>(x.load.get.i == 42);
    <span class="keyword">assert</span>(y.get.i == 123);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.compareExchangeStrong" id="IntrusivePtr.compareExchangeStrong"><code class="code">compareExchangeStrong</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.compareExchangeStrong"></span>scope bool <code class="code">compareExchangeStrong</code>(MemoryOrder success = MemoryOrder.seq, MemoryOrder failure = success, E, D, this This)(ref scope E <code class="code">expected</code>, scope D <code class="code">desired</code>) if (isIntrusivePtr!E &amp;&amp; !is(E == shared) &amp;&amp; isIntrusivePtr!D &amp;&amp; !is(D == shared) &amp;&amp; (isMoveConstructable!(D, This) &amp;&amp; isMutable!This) &amp;&amp; (isCopyConstructable!(This, E) &amp;&amp; isMutable!E) &amp;&amp; (This.isWeak == D.isWeak) &amp;&amp; (This.isWeak == E.isWeak));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Compares the <code class="code">IntrusivePtr</code> pointers pointed-to by <code class="code">this</code> and <code class="code"><code class="code">expected</code></code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns <code class="code"><code class="code">desired</code></code> into <code class="code">this</code> using the memory ordering constraints specified by <code class="code">success</code> and returns <code class="code">true</code>.
            If they are not equivalent, assigns <code class="code">this</code> into <code class="code"><code class="code">expected</code></code> using the memory ordering constraints specified by <code class="code">failure</code> and returns <code class="code">false</code>.
<br><br>
            More info in c++ std::atomic<std::shared_ptr>.
<br><br>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">class</span> Foo{
    <span class="keyword">long</span> i;
    MutableControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;

    <span class="keyword">this</span>(<span class="keyword">long</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }

    <span class="keyword">bool</span> opEquals(<span class="keyword">this</span> This)(<span class="keyword">long</span> i)<span class="keyword">const</span> @trusted{
        <span class="keyword">import</span> std.traits : Unqual;
        <span class="keyword">auto</span> self = <span class="keyword">cast</span>(Unqual!This)<span class="keyword">this</span>;
        <span class="keyword">return</span> (self.i == i);
    }
}

<span class="keyword">alias</span> Type = <span class="keyword">const</span> Foo;

<span class="keyword">static</span> <span class="keyword">foreach</span>(<span class="keyword">enum</span> <span class="keyword">bool</span> weak; [<span class="keyword">true</span>, <span class="keyword">false</span>]){
    <span class="comment">//fail
</span>    {
        IntrusivePtr!Type a = IntrusivePtr!Type.make(123);
        IntrusivePtr!Type b = IntrusivePtr!Type.make(42);
        IntrusivePtr!Type c = IntrusivePtr!Type.make(666);

        <span class="keyword">static</span> <span class="keyword">if</span>(weak)a.compareExchangeWeak(b, c);
        <span class="keyword">else</span> a.<span class="psymbol">compareExchangeStrong</span>(b, c);

        <span class="keyword">assert</span>(*a == 123);
        <span class="keyword">assert</span>(*b == 123);
        <span class="keyword">assert</span>(*c == 666);

    }

    <span class="comment">//success
</span>    {
        IntrusivePtr!Type a = IntrusivePtr!Type.make(123);
        IntrusivePtr!Type b = a;
        IntrusivePtr!Type c = IntrusivePtr!Type.make(666);

        <span class="keyword">static</span> <span class="keyword">if</span>(weak)a.compareExchangeWeak(b, c);
        <span class="keyword">else</span> a.<span class="psymbol">compareExchangeStrong</span>(b, c);

        <span class="keyword">assert</span>(*a == 666);
        <span class="keyword">assert</span>(*b == 123);
        <span class="keyword">assert</span>(*c == 666);
    }

    <span class="comment">//shared fail
</span>    {
        <span class="keyword">shared</span> IntrusivePtr!(<span class="keyword">shared</span> Type) a = IntrusivePtr!(<span class="keyword">shared</span> Type).make(123);
        IntrusivePtr!(<span class="keyword">shared</span> Type) b = IntrusivePtr!(<span class="keyword">shared</span> Type).make(42);
        IntrusivePtr!(<span class="keyword">shared</span> Type) c = IntrusivePtr!(<span class="keyword">shared</span> Type).make(666);

        <span class="keyword">static</span> <span class="keyword">if</span>(weak)a.compareExchangeWeak(b, c);
        <span class="keyword">else</span> a.<span class="psymbol">compareExchangeStrong</span>(b, c);

        <span class="keyword">auto</span> tmp = a.exchange(<span class="keyword">null</span>);
        <span class="keyword">assert</span>(*tmp == 123);
        <span class="keyword">assert</span>(*b == 123);
        <span class="keyword">assert</span>(*c == 666);
    }

    <span class="comment">//shared success
</span>    {
        IntrusivePtr!(<span class="keyword">shared</span> Type) b = IntrusivePtr!(<span class="keyword">shared</span> Type).make(123);
        <span class="keyword">shared</span> IntrusivePtr!(<span class="keyword">shared</span> Type) a = b;
        IntrusivePtr!(<span class="keyword">shared</span> Type) c = IntrusivePtr!(<span class="keyword">shared</span> Type).make(666);

        <span class="keyword">static</span> <span class="keyword">if</span>(weak)a.compareExchangeWeak(b, c);
        <span class="keyword">else</span> a.<span class="psymbol">compareExchangeStrong</span>(b, c);

        <span class="keyword">auto</span> tmp = a.exchange(<span class="keyword">null</span>);
        <span class="keyword">assert</span>(*tmp == 666);
        <span class="keyword">assert</span>(*b == 123);
        <span class="keyword">assert</span>(*c == 666);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.compareExchangeWeak" id="IntrusivePtr.compareExchangeWeak"><code class="code">compareExchangeWeak</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.compareExchangeWeak"></span>scope bool <code class="code">compareExchangeWeak</code>(MemoryOrder success = MemoryOrder.seq, MemoryOrder failure = success, E, D, this This)(ref scope E <code class="code">expected</code>, scope D <code class="code">desired</code>) if (isIntrusivePtr!E &amp;&amp; !is(E == shared) &amp;&amp; isIntrusivePtr!D &amp;&amp; !is(D == shared) &amp;&amp; (isMoveConstructable!(D, This) &amp;&amp; isMutable!This) &amp;&amp; (isCopyConstructable!(This, E) &amp;&amp; isMutable!E) &amp;&amp; (This.isWeak == D.isWeak) &amp;&amp; (This.isWeak == E.isWeak));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Same as <code class="code">compareExchangeStrong</code> but may fail spuriously.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    More info in c++ <code class="code">std::atomic&lt;std::shared_ptr&gt;</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.lock" id="IntrusivePtr.lock"><code class="code">lock</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.lock"></span>scope SharedType <code class="code">lock</code>()() if (isCopyConstructable!(typeof(this), SharedType));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Creates a new non weak <code class="code">IntrusivePtr</code> that shares ownership of the managed object (must be <code class="code">IntrusivePtr.WeakType</code>).

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If there is no managed object, i.e. this is empty or this is <code class="code">expired</code>, then the returned <code class="code">IntrusivePtr</code> is empty.
            Method exists only if <code class="code">IntrusivePtr</code> is <code class="code">isWeak</code>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);

    <span class="keyword">auto</span> w = x.weak;    <span class="comment">//weak ptr
</span>
    IntrusivePtr!Foo y = w.<span class="psymbol">lock</span>;

    <span class="keyword">assert</span>(x == y);
    <span class="keyword">assert</span>(x.useCount == 2);
    <span class="keyword">assert</span>(y.get.i == 123);
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);

    <span class="keyword">auto</span> w = x.weak;    <span class="comment">//weak ptr
</span>
    <span class="keyword">assert</span>(w.expired == <span class="keyword">false</span>);

    x = IntrusivePtr!Foo.make(321);

    <span class="keyword">assert</span>(w.expired == <span class="keyword">true</span>);

    IntrusivePtr!Foo y = w.<span class="psymbol">lock</span>;

    <span class="keyword">assert</span>(y == <span class="keyword">null</span>);
}

{
    <span class="keyword">shared</span> IntrusivePtr!(<span class="keyword">shared</span> Foo) x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);

    <span class="keyword">shared</span> IntrusivePtr!(<span class="keyword">shared</span> Foo).WeakType w = x.load.weak;    <span class="comment">//weak ptr
</span>
    <span class="keyword">assert</span>(w.expired == <span class="keyword">false</span>);

    x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(321);

    <span class="keyword">assert</span>(w.expired == <span class="keyword">true</span>);

    IntrusivePtr!(<span class="keyword">shared</span> Foo) y = w.load.<span class="psymbol">lock</span>;

    <span class="keyword">assert</span>(y == <span class="keyword">null</span>);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.expired" id="IntrusivePtr.expired"><code class="code">expired</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.expired"></span>const nothrow @nogc @property scope @safe bool <code class="code">expired</code>(this This)();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Equivalent to <code class="code">useCount() == 0</code> (must be <code class="code">IntrusivePtr.WeakType</code>).

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Method exists only if <code class="code">IntrusivePtr</code> is <code class="code">isWeak</code>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);

    <span class="keyword">auto</span> wx = x.weak;   <span class="comment">//weak pointer
</span>
    <span class="keyword">assert</span>(wx.<span class="psymbol">expired</span> == <span class="keyword">false</span>);

    x = <span class="keyword">null</span>;

    <span class="keyword">assert</span>(wx.<span class="psymbol">expired</span> == <span class="keyword">true</span>);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opUnary" id="IntrusivePtr.opUnary"><code class="code">opUnary</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opUnary"></span>template <code class="code">opUnary</code>(string op : "*") if (op == "*")
          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Operator *, same as method 'get'.

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;
    <span class="keyword">alias</span> i <span class="keyword">this</span>;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(*x == 123);
((*x).i = 321);
<span class="keyword">assert</span>(*x == 321);
<span class="keyword">const</span> y = x;
<span class="keyword">assert</span>(*y == 321);
<span class="keyword">assert</span>(*x == 321);
<span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(*y) == <span class="keyword">const</span> Foo));
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.get" id="IntrusivePtr.get"><code class="code">get</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.get"></span>inout pure nothrow @nogc @property @safe inout(ElementType) <code class="code">get</code>() return;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Get reference to managed object of <code class="code">ElementType</code> or value if <code class="code">ElementType</code> is reference type (class or interface) or dynamic array.

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(x.<span class="psymbol">get</span>.i == 123);
x.<span class="psymbol">get</span>.i = 321;
<span class="keyword">assert</span>(x.<span class="psymbol">get</span>.i == 321);
<span class="keyword">const</span> y = x;
<span class="keyword">assert</span>(y.<span class="psymbol">get</span>.i == 321);
<span class="keyword">assert</span>(x.<span class="psymbol">get</span>.i == 321);
<span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(y.<span class="psymbol">get</span>) == <span class="keyword">const</span> Foo));
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.element" id="IntrusivePtr.element"><code class="code">element</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.element"></span>inout pure nothrow @nogc @property @system ElementReferenceTypeImpl!(inout(ElementType)) <code class="code">element</code>() return;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Get pointer to managed object of <code class="code">ElementType</code> or reference if <code class="code">ElementType</code> is reference type (class or interface) or dynamic array

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If <code class="code">this</code> is weak expired pointer then return <code class="code">null</code>.
<br><br>
            Doesn't increment useCount, is inherently unsafe.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
    <span class="keyword">assert</span>(x.<span class="psymbol">element</span>.i == 123);

    x.get.i = 321;
    <span class="keyword">assert</span>(x.<span class="psymbol">element</span>.i == 321);

    <span class="keyword">const</span> y = x;
    <span class="keyword">assert</span>(y.<span class="psymbol">element</span>.i == 321);
    <span class="keyword">assert</span>(x.<span class="psymbol">element</span>.i == 321);

    <span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(y.<span class="psymbol">element</span>) == <span class="keyword">const</span>(Foo)*));
}

{
    <span class="keyword">auto</span> s = IntrusivePtr!Foo.make(42);
    <span class="keyword">const</span> w = s.weak;

    <span class="keyword">assert</span>(w.<span class="psymbol">element</span>.i == 42);

    s = <span class="keyword">null</span>;
    <span class="keyword">assert</span>(w.<span class="psymbol">element</span> <span class="keyword">is</span> <span class="keyword">null</span>);
}

{
    <span class="keyword">auto</span> s = IntrusivePtr!Foo.make(42);
    <span class="keyword">auto</span> w = s.weak;

    <span class="keyword">scope</span> <span class="keyword">const</span> p = w.<span class="psymbol">element</span>;

    s = <span class="keyword">null</span>;
    <span class="keyword">assert</span>(w.<span class="psymbol">element</span> <span class="keyword">is</span> <span class="keyword">null</span>);

    <span class="keyword">assert</span>(p !<span class="keyword">is</span> <span class="keyword">null</span>); <span class="comment">//p is dangling pointer!
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.weak" id="IntrusivePtr.weak"><code class="code">weak</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.weak"></span>scope WeakType <code class="code">weak</code>()() if (isCopyConstructable!(typeof(this), WeakType));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">weak</code> pointer (must have <code class="code">weak</code> counter).

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(x.useCount == 1);

<span class="keyword">auto</span> wx = x.<span class="psymbol">weak</span>;   <span class="comment">//weak pointer
</span><span class="keyword">assert</span>(wx.expired == <span class="keyword">false</span>);
<span class="keyword">assert</span>(wx.lock.get.i == 123);
<span class="keyword">assert</span>(wx.useCount == 1);

x = <span class="keyword">null</span>;
<span class="keyword">assert</span>(wx.expired == <span class="keyword">true</span>);
<span class="keyword">assert</span>(wx.useCount == 0);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opCastImpl" id="IntrusivePtr.opCastImpl"><code class="code">opCastImpl</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opCastImpl"></span>const pure nothrow @nogc scope @safe bool <code class="code">opCastImpl</code>(To : bool)() if (is(To : bool));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Checks if <code class="code">this</code> stores a non-<code class="code">null</code> pointer, i.e. whether <code class="code">this != null</code>.

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">BUG:</span>
qualfied variable of struct with dtor cannot be inside other struct (generated dtor will use opCast to mutable before dtor call ). opCast is renamed to <code class="code">opCastImpl</code>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(<span class="keyword">cast</span>(<span class="keyword">bool</span>)x);    <span class="comment">//explicit cast
</span><span class="keyword">assert</span>(x);              <span class="comment">//implicit cast
</span>x = <span class="keyword">null</span>;
<span class="keyword">assert</span>(!<span class="keyword">cast</span>(<span class="keyword">bool</span>)x);   <span class="comment">//explicit cast
</span><span class="keyword">assert</span>(!x);             <span class="comment">//implicit cast
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opCastImpl" id="IntrusivePtr.opCastImpl"><code class="code">opCastImpl</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opCastImpl.2"></span>scope To <code class="code">opCastImpl</code>(To, this This)() if (isIntrusivePtr!To &amp;&amp; !is(This == shared));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Cast <code class="code">this</code> to different type <code class="code">To</code> when <code class="code">isIntrusivePtr!To</code>.

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">BUG:</span>
qualfied variable of struct with dtor cannot be inside other struct (generated dtor will use opCast to mutable before dtor call ). opCast is renamed to <code class="code">opCastImpl</code>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;
    <span class="keyword">alias</span> i <span class="keyword">this</span>;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

<span class="keyword">import</span> std.conv;

IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
<span class="keyword">assert</span>(x.useCount == 1
);
<span class="keyword">auto</span> y = <span class="keyword">cast</span>(IntrusivePtr!(<span class="keyword">const</span> Foo))x;
<span class="comment">//debug assert(x.useCount == 2, x.useCount.to!string);
</span><span class="keyword">assert</span>(x.useCount == 2);


<span class="keyword">auto</span> z = <span class="keyword">cast</span>(<span class="keyword">const</span> IntrusivePtr!Foo)x;
<span class="keyword">assert</span>(x.useCount == 3);

<span class="keyword">auto</span> u = <span class="keyword">cast</span>(<span class="keyword">const</span> IntrusivePtr!(<span class="keyword">const</span> Foo))x;
<span class="keyword">assert</span>(x.useCount == 4);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opEquals" id="IntrusivePtr.opEquals"><code class="code">opEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opEquals"></span>const pure nothrow @nogc scope @safe bool <code class="code">opEquals</code>(typeof(null) <code class="code">nil</code>);
<br>
const pure nothrow @nogc scope @safe bool <code class="code">opEquals</code>(Rhs)(auto ref scope const Rhs <code class="code">rhs</code>) if (isIntrusivePtr!Rhs &amp;&amp; !is(Rhs == shared));
<br>
const pure nothrow @nogc scope @safe bool <code class="code">opEquals</code>(Elm)(scope const Elm <code class="code">elm</code>) if (is(Elm : GetElementReferenceType!(typeof(this))));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Operator == and != .
            Compare pointers.

  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(0);
    <span class="keyword">assert</span>(x != <span class="keyword">null</span>);
    x = <span class="keyword">null</span>;
    <span class="keyword">assert</span>(x == <span class="keyword">null</span>);
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
    IntrusivePtr!Foo y = IntrusivePtr!Foo.make(123);
    <span class="keyword">assert</span>(x == x);
    <span class="keyword">assert</span>(y == y);
    <span class="keyword">assert</span>(x != y);
}

{
    IntrusivePtr!Foo x;
    IntrusivePtr!(<span class="keyword">const</span> Foo) y;
    <span class="keyword">assert</span>(x == x);
    <span class="keyword">assert</span>(y == y);
    <span class="keyword">assert</span>(x == y);
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
    IntrusivePtr!Foo y = IntrusivePtr!Foo.make(123);
    <span class="keyword">assert</span>(x == x.element);
    <span class="keyword">assert</span>(y.element == y);
    <span class="keyword">assert</span>(x != y.element);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.opCmp" id="IntrusivePtr.opCmp"><code class="code">opCmp</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.opCmp"></span>const pure nothrow @nogc scope @trusted sizediff_t <code class="code">opCmp</code>(typeof(null) <code class="code">nil</code>);
<br>
const pure nothrow @nogc scope @trusted sizediff_t <code class="code">opCmp</code>(Elm)(scope const Elm <code class="code">elm</code>) if (is(Elm : GetElementReferenceType!(typeof(this))));
<br>
const pure nothrow @nogc scope @trusted sizediff_t <code class="code">opCmp</code>(Rhs)(auto ref scope const Rhs <code class="code">rhs</code>) if (isIntrusivePtr!Rhs &amp;&amp; !is(Rhs == shared));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Operators &lt;, &lt;=, &gt;, &gt;= for <code class="code">IntrusivePtr</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Compare address of payload.


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    <span class="keyword">const</span> a = IntrusivePtr!Foo.make(42);
    <span class="keyword">const</span> b = IntrusivePtr!Foo.make(123);
    <span class="keyword">const</span> n = IntrusivePtr!Foo.init;

    <span class="keyword">assert</span>(a &lt;= a);
    <span class="keyword">assert</span>(a &gt;= a);

    <span class="keyword">assert</span>((a &lt; b) == !(a &gt;= b));
    <span class="keyword">assert</span>((a &gt; b) == !(a &lt;= b));

    <span class="keyword">assert</span>(a &gt; n);
    <span class="keyword">assert</span>(a &gt; <span class="keyword">null</span>);

    <span class="keyword">assert</span>(n &lt; a);
    <span class="keyword">assert</span>(<span class="keyword">null</span> &lt; a);
}

{
    <span class="keyword">const</span> a = IntrusivePtr!Foo.make(42);
    <span class="keyword">const</span> b = IntrusivePtr!Foo.make(123);

    <span class="keyword">assert</span>(a &lt;= a.element);
    <span class="keyword">assert</span>(a.element &gt;= a);

    <span class="keyword">assert</span>((a &lt; b.element) == !(a.element &gt;= b));
    <span class="keyword">assert</span>((a &gt; b.element) == !(a.element &lt;= b));
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr.toHash" id="IntrusivePtr.toHash"><code class="code">toHash</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr.toHash"></span>const pure nothrow @nogc @property scope @trusted size_t <code class="code">toHash</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Generate hash

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Return:</span>
Address of payload as <code class="code">size_t</code>


  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    IntrusivePtr!Foo x = IntrusivePtr!Foo.make(123);
    IntrusivePtr!Foo y = IntrusivePtr!Foo.make(123);
    <span class="keyword">assert</span>(x.<span class="psymbol">toHash</span> == x.<span class="psymbol">toHash</span>);
    <span class="keyword">assert</span>(y.<span class="psymbol">toHash</span> == y.<span class="psymbol">toHash</span>);
    <span class="keyword">assert</span>(x.<span class="psymbol">toHash</span> != y.<span class="psymbol">toHash</span>);
    IntrusivePtr!(<span class="keyword">const</span> Foo) z = x;
    <span class="keyword">assert</span>(x.<span class="psymbol">toHash</span> == z.<span class="psymbol">toHash</span>);
}
{
    IntrusivePtr!Foo x;
    IntrusivePtr!(<span class="keyword">const</span> Foo) y;
    <span class="keyword">assert</span>(x.<span class="psymbol">toHash</span> == x.<span class="psymbol">toHash</span>);
    <span class="keyword">assert</span>(y.<span class="psymbol">toHash</span> == y.<span class="psymbol">toHash</span>);
    <span class="keyword">assert</span>(x.<span class="psymbol">toHash</span> == y.<span class="psymbol">toHash</span>);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li>
</ul>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#IntrusivePtr" id="IntrusivePtr"><code class="code">IntrusivePtr</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="IntrusivePtr"></span>template <code class="code">IntrusivePtr</code>(_Type, _DestructorType, _ControlType = IntrusiveControlBlock!_Type, bool _weakPtr = false) if (isControlBlock!_ControlType &amp;&amp; isDestructorType!_DestructorType)<br>
template <code class="code">IntrusivePtr</code>(_Type, _ControlType, _DestructorType, bool _weakPtr = false) if (isControlBlock!_ControlType &amp;&amp; isDestructorType!_DestructorType)
          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Alias to <code class="code"><code class="code">IntrusivePtr</code></code> with additional template parameters for same interface as <code class="code">SharedPtr</code> and <code class="code">RcPtr</code>
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#dynCast" id="dynCast"><code class="code">dynCast</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="dynCast"></span>UnqualSmartPtr!Ptr.ChangeElementType!T <code class="code">dynCast</code>(T, Ptr)(ref scope Ptr <code class="code">ptr</code>) if (isIntrusive!T &amp;&amp; isIntrusivePtr!Ptr &amp;&amp; !is(Ptr == shared) &amp;&amp; !Ptr.isWeak &amp;&amp; isReferenceType!T &amp;&amp; (__traits(getLinkage, T) == "D") &amp;&amp; isReferenceType!(Ptr.ElementType) &amp;&amp; (__traits(getLinkage, Ptr.ElementType) == "D"));
<br>
UnqualSmartPtr!Ptr.ChangeElementType!T <code class="code">dynCast</code>(T, Ptr)(scope Ptr <code class="code">ptr</code>) if (isIntrusive!T &amp;&amp; isIntrusivePtr!Ptr &amp;&amp; !is(Ptr == shared) &amp;&amp; !Ptr.isWeak &amp;&amp; isReferenceType!T &amp;&amp; (__traits(getLinkage, T) == "D") &amp;&amp; isReferenceType!(Ptr.ElementType) &amp;&amp; (__traits(getLinkage, Ptr.ElementType) == "D"));
<br>
<span class="ddoc_anchor" id="dynCastMove"></span>UnqualSmartPtr!Ptr.ChangeElementType!T <code class="code">dynCastMove</code>(T, Ptr)(auto ref scope Ptr <code class="code">ptr</code>) if (isIntrusive!T &amp;&amp; isIntrusivePtr!Ptr &amp;&amp; !is(Ptr == shared) &amp;&amp; !Ptr.isWeak &amp;&amp; isReferenceType!T &amp;&amp; (__traits(getLinkage, T) == "D") &amp;&amp; isReferenceType!(Ptr.ElementType) &amp;&amp; (__traits(getLinkage, Ptr.ElementType) == "D"));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Dynamic cast for shared pointers if <code class="code">ElementType</code> is class with D linkage.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Creates a new instance of <code class="code">IntrusivePtr</code> whose stored pointer is obtained from <code class="code"><code class="code">ptr</code></code>'s stored pointer using a dynaic cast expression.
<br><br>
    If <code class="code"><code class="code">ptr</code></code> is <code class="code">null</code> or dynamic cast fail then result <code class="code">IntrusivePtr</code> is <code class="code">null</code>.
    Otherwise, the new <code class="code">IntrusivePtr</code> will share ownership with the initial value of <code class="code"><code class="code">ptr</code></code>.
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">class</span> Base{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
}
<span class="keyword">static</span> <span class="keyword">class</span> Foo : Base{
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

<span class="keyword">static</span> <span class="keyword">class</span> Bar : Foo{
    <span class="keyword">double</span> d;

    <span class="keyword">this</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> d)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">super</span>(i);
        <span class="keyword">this</span>.d = d;
    }
}

<span class="keyword">static</span> <span class="keyword">class</span> Zee : Base{
}

{
    IntrusivePtr!(<span class="keyword">const</span> Foo) foo = IntrusivePtr!Bar.make(42, 3.14);
    <span class="comment">//assert(foo.get.i == 42);
</span>
    <span class="keyword">auto</span> bar = <span class="psymbol">dynCastMove</span>!Bar(foo);
    <span class="keyword">assert</span>(bar != <span class="keyword">null</span>);
    <span class="comment">//assert(bar.get.d == 3.14);
</span>    <span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(bar) == IntrusivePtr!(<span class="keyword">const</span> Bar)));

    <span class="keyword">auto</span> zee = <span class="psymbol">dynCastMove</span>!Zee(bar);
    <span class="keyword">assert</span>(zee == <span class="keyword">null</span>);
    <span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(zee) == IntrusivePtr!(<span class="keyword">const</span> Zee)));
}

{
    IntrusivePtr!(<span class="keyword">const</span> Foo) foo = IntrusivePtr!Bar.make(42, 3.14);
    <span class="comment">//assert(foo.get.i == 42);
</span>
    <span class="keyword">auto</span> bar = <span class="psymbol">dynCastMove</span>!Bar(foo);
    <span class="keyword">assert</span>(bar != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(foo == <span class="keyword">null</span>);
    <span class="comment">//assert(bar.get.d == 3.14);
</span>    <span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(bar) == IntrusivePtr!(<span class="keyword">const</span> Bar)));

    <span class="keyword">auto</span> zee = <span class="psymbol">dynCastMove</span>!Zee(bar);
    <span class="keyword">assert</span>(bar != <span class="keyword">null</span>);
    <span class="keyword">assert</span>(zee == <span class="keyword">null</span>);
    <span class="keyword">static</span> <span class="keyword">assert</span>(<span class="keyword">is</span>(<span class="keyword">typeof</span>(zee) == IntrusivePtr!(<span class="keyword">const</span> Zee)));
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#share" id="share"><code class="code">share</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="share"></span>shared(Ptr) <code class="code">share</code>(Ptr)(auto ref scope Ptr <code class="code">ptr</code>) if (isIntrusivePtr!Ptr);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">shared IntrusivePtr</code> pointing to same managed object like parameter <code class="code"><code class="code">ptr</code></code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Type of parameter <code class="code"><code class="code">ptr</code></code> must be <code class="code">IntrusivePtr</code> with <code class="code">shared(ControlType)</code> and <code class="code">shared</code>/<code class="code">immutable</code> <code class="code">ElementType</code> .
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">struct</span> Foo{
    ControlBlock!(<span class="keyword">int</span>, <span class="keyword">int</span>) c;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    <span class="keyword">auto</span> x = IntrusivePtr!(<span class="keyword">shared</span> Foo).make(123);
    <span class="keyword">assert</span>(x.useCount == 1);

    <span class="keyword">shared</span> s1 = <span class="psymbol">share</span>(x);
    <span class="keyword">assert</span>(x.useCount == 2);


    <span class="keyword">import</span> core.lifetime : move;
    <span class="keyword">shared</span> s2 = <span class="psymbol">share</span>(x.move);
    <span class="keyword">assert</span>(x == <span class="keyword">null</span>);
    <span class="keyword">assert</span>(s2.useCount == 2);
    <span class="keyword">assert</span>(s2.load.get.i == 123);

}

{
    <span class="keyword">auto</span> x = IntrusivePtr!(Foo).make(123);
    <span class="keyword">assert</span>(x.useCount == 1);

    <span class="comment">///error `shared IntrusivePtr` need shared `ControlType` and shared `ElementType`.
</span>    <span class="comment">//shared s1 = share(x);
</span>
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#intrusivePtr" id="intrusivePtr"><code class="code">intrusivePtr</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="intrusivePtr"></span>auto <code class="code">intrusivePtr</code>(Elm)(Elm <code class="code">elm</code>) if (is(Elm == class) &amp;&amp; isIntrusive!Elm);
<br>
auto <code class="code">intrusivePtr</code>(Ptr : Elm*, Elm)(Ptr <code class="code">elm</code>) if (is(Elm == struct) &amp;&amp; isIntrusive!Elm);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Create <code class="code">IntrusivePtr</code> instance from class reference <code class="code">Elm</code> or struct pointer element <code class="code">Elm</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    <code class="code">Elm</code> was created by <code class="code">IntrusivePtr.make</code> or <code class="code">IntrusivePtr.alloc</code>.
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">static</span> <span class="keyword">class</span> Foo{
    <span class="keyword">private</span> ControlBlock!<span class="keyword">int</span> control;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}
<span class="keyword">static</span> <span class="keyword">struct</span> Bar{
    <span class="keyword">private</span> ControlBlock!<span class="keyword">int</span> control;
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i)<span class="keyword">pure</span> <span class="keyword">nothrow</span> @safe @nogc{
        <span class="keyword">this</span>.i = i;
    }
}

{
    <span class="keyword">auto</span> i = IntrusivePtr!Foo.make(42);
    <span class="keyword">assert</span>(i.useCount == 1);

    Foo foo = i.get;

    <span class="keyword">auto</span> i2 = <span class="psymbol">intrusivePtr</span>(foo);
    <span class="keyword">assert</span>(i.useCount == 2);
}

{
    <span class="keyword">auto</span> i = IntrusivePtr!Bar.make(42);
    <span class="keyword">assert</span>(i.useCount == 1);

    Bar* bar = i.element;

    <span class="keyword">auto</span> i2 = <span class="psymbol">intrusivePtr</span>(bar);
    <span class="keyword">assert</span>(i.useCount == 2);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>
